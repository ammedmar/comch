from collections import Counter


class ModuleElement(Counter):
    r"""Element in a free module over :math:`\mathbb{Z}` or
    :math:`\mathbb{Z}/n \mathbb{Z}`.

    Let :math:`R` be a ring and :math:`B` a set. The free :math:`R`-module
    generated by :math:`B` consists of all :math:`R`-linear combination of
    elements in :math:`B`

    .. math::
        R[B] = \Big\{ \sum_i r_ib_i\ |\ r_i \in R, b_i \in B \Big\}.

    For a ring :math:`R` equal to :math:`\mathbb Z` or
    :math:`\mathbb Z/m\mathbb Z` this class models elements in free
    :math:`R`-modules. The ring is specified via the class attribute
    ‘torsion‘, where ‘free’ sets :math:`R = \mathbb Z` and a positive
    ‘int‘ sets :math:`R = \mathbb Z/n\mathbb Z`. The class supports
    addition, substraction and scaling.

    PARAMETERS
    ----------
    data : ``dict`` or ``None``, default: ``None``
        Dictionary representing a linear cobination of basis elements.
        Items in the dict correspond with pairs (basis_element: coefficient).
    torsion : int or 'free', default 'free'
        The torsion of the underlying ring.

    ATTRIBUTES
    ----------
    torsion : int or 'free'
        The torsion of the underlying ring.

    EXAMPLE
    -------
    >>> print(ModuleElement())
    0
    >>> print(ModuleElement({'a': 1, 'b': -1, 'c': 0}))
    a - b

    """

    default_torsion = 'free'

    def __init__(self, data=None, torsion=None):

        if torsion is None:
            torsion = type(self).default_torsion

        self.torsion = torsion

        super(ModuleElement, self).__init__(data)

        self.preferred_rep()

    def __hash__(self):
        return hash(frozenset(self))

    def __str__(self):
        """Coefficient first representation."""
        if not self:
            return '0'
        else:
            answer = ''
            for key, value in self.items():
                if value < -1:
                    answer += f'- {abs(value)}{key} '
                elif value == -1:
                    answer += f'- {key} '
                elif value == 1:
                    answer += f'+ {key} '
                elif value > 1:
                    answer += f'+ {value}{key} '
            if answer[0] == '+':
                answer = answer[2:]

            return answer[:-1]

    def __add__(self, other):
        """Addition: *self* + *other*.

        PARAMETERS
        ----------
        other : :class:`comch.module.ModuleElement` object
            The element to add to *self*.

        RETURNS
        -------
        :class:`comch.module.ModuleElement` object
            The sum of *self* and *other*.

        EXAMPLE
        -------
        >>> ModuleElement({'a': 1, 'b': 2}) + ModuleElement({'a': 1})
        ModuleElement({'a': 2, 'b': 2})

        """
        if self.torsion != other.torsion:
            raise TypeError('only defined for equal attribute torsion')
        answer = self.create(self)
        answer.update(other)
        answer.preferred_rep()
        return answer

    def __sub__(self, other):
        """Diference: *self* - *other*.

        PARAMETERS
        ----------
        other : :class:`comch.module.ModuleElement` object
            The element to substract from *self*.

        RETURNS
        -------
        :class:`comch.module.ModuleElement` object
            The difference of *self* and *other*.

        EXAMPLE
        -------
        >>> ModuleElement({'a': 1, 'b': 2}) - ModuleElement({'a': 1})
        ModuleElement({'b': 2})

        """
        if self.torsion != other.torsion:
            raise TypeError('only defined for equal attribute torsion')
        answer = self.create(self)
        answer.subtract(other)
        answer.preferred_rep()
        return answer

    def __rmul__(self, c):
        """Scaling: *c* * *self*.

        PARAMETERS
        ----------
        c : int
            The element to scale *self*. by.

        RETURNS
        -------
        :class:`comch.module.ModuleElement` object
            The scaling of *self* by *other*.

        EXAMPLE
        -------
        >>> 3 * ModuleElement({'a':1, 'b':2})
        ModuleElement({'b': 6, 'a': 3})

        """
        if not isinstance(c, int):
            raise TypeError(f'Act only by int not by type {type(c)}')

        scaled = {k: c * v for k, v in self.items()}
        return self.create(scaled)

    def __neg__(self):
        """Additive inverse: - *self*.

        RETURNS
        -------
        :class:`comch.module.ModuleElement` object
            the additive inverse of *self*.

        EXAMPLE
        -------
        >>> - ModuleElement({'a': 1, 'b': 2})
        ModuleElement({'a': -1, 'b': -2})

        """
        return self.__rmul__(-1)

    def __iadd__(self, other):
        """In place addition: *self* += *other*.

        PARAMETERS
        ----------
        other : :class:`comch.module.ModuleElement` object
            The element to add to *self*.

        EXAMPLE
        -------
        >>> x = ModuleElement({'a': 1, 'b': 2})
        >>> x += ModuleElement({'a': 3, 'b': 6})
        >>> x
        ModuleElement({'b': 8, 'a': 4})

        """
        if self.torsion != other.torsion:
            raise TypeError('only defined for equal attribute torsion')
        self.update(other)
        self.preferred_rep()
        return self

    def __isub__(self, other):
        """In place difference: *self* -= *other*.

        PARAMETERS
        ----------
        other : :class:`comch.module.ModuleElement` object
            The element to substract from *self*.

        EXAMPLE
        -------
        >>> x = ModuleElement({'a': 1, 'b': 2})
        >>> x -= ModuleElement({'a': 3, 'b': 6})
        >>> x
        ModuleElement({'a': -2, 'b': -4})

        """
        if self.torsion != other.torsion:
            raise TypeError('only defined for equal attribute torsion')
        self.subtract(other)
        self.preferred_rep()
        return self

    def preferred_rep(self):
        """The preferred representative of *self*.

        The preferred representative has coefficient in {0,...,torsion-1}
        if attribute torsion is not 'free', and no pairs key:value with
        value = 0.

        EXAMPLE
        -------
        >>> ModuleElement({'a': 1, 'b': 2, 'c': 0})
        ModuleElement({'b': 2, 'a': 1})

        """
        # reducing coefficients mod torsion
        if self.torsion != 'free':
            for key, value in self.items():
                self[key] = value % self.torsion

        # removing key:value pairs with value = 0
        zeros = [k for k, v in self.items() if not v]
        for key in zeros:
            del self[key]

    def set_torsion(self, torsion):
        """Sets the torsion of *self*.

        PARAMETERS
        ----------
        torsion : int or 'free'
            The new `torsion` of *self*

        EXAMPLE
        -------
        >>> ModuleElement({'a': 1, 'b': 2}).set_torsion(2)
        ModuleElement({'a': 1})

        """
        setattr(self, 'torsion', torsion)
        self.preferred_rep()
        return self

    def create(self, other=None):
        """Instantiates data with same type and attribute values as *self*.

        PARAMETERS
        ----------
        other : dict or None, default: ``None``
            Data to be initialized.

        RETURNS
        -------
        type(*self*) object
            The initialized object with the given data

        EXAMPLE
        -------
        >>> x =  ModuleElement({'a': 1})
        >>> x + x.create({'b': 1})
        ModuleElement({'a': 1, 'b': 1})

        """
        answer = type(self)(other)
        answer.__dict__ = self.__dict__
        return answer

    def zero(self):
        """Instantiates 0 with same type and attribute values as *self*.

        RETURNS
        -------
        type(*self*) object
            The initialized empty object

        EXAMPLE
        -------
        >>> x = ModuleElement({'a': 1})
        >>> x + x.zero() == x
        True

        """
        return self.create()
